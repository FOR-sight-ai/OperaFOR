<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>LLM + MCP Demo (Qwen-style Tools)</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 2em;
            background: #f9f9f9;
        }

        textarea,
        input,
        button {
            width: 100%;
            padding: 1em;
            margin-bottom: 1em;
            font-family: monospace;
            font-size: 1em;
        }

        pre {
            background: #333;
            color: #eee;
            padding: 1em;
            border-radius: 5px;
            overflow-x: auto;
            white-space: pre-wrap;
        }

        #configPanel {
            display: none;
            margin-bottom: 1em;
        }

        .toggle-button {
            background-color: #007BFF;
            color: white;
            border: none;
            padding: 0.5em 1em;
            cursor: pointer;
            font-size: 1em;
            margin-bottom: 1em;
        }
    </style>
    <!-- Si vous n'utilisez pas de bundler, décommentez la ligne suivante pour charger la lib MCP depuis un CDN -->
    <script src="https://unpkg.com/@mcp/tools/dist/umd/index.js"></script>
</head>

<body>
    <h1>LLM + MCP Demo (Qwen-style Tools)</h1>

    <button class="toggle-button" onclick="toggleConfig()">Show Configuration</button>
    <div id="configPanel">
        <h3>Configuration (JSON)</h3>
        <textarea id="config" rows="8"></textarea>
    </div>

    <h3>User Request</h3>
    <textarea id="userInput" rows="4">What's the weather in Paris using mcp tool?</textarea>

    <button onclick="run()">Run</button>

    <h3>Response</h3>
    <pre id="output">Waiting...</pre>

    <script>
        // Si vous utilisez un bundler, décommentez les lignes suivantes
        // npm install @mcp/tools
        // import { discoverTools, callTool } from "@mcp/tools";

        function setConfig(value) {
            localStorage.setItem('llmConfig', value);
        }

        function getConfig() {
            return localStorage.getItem('llmConfig');
        }

        const defaultConfig = `{
  "llm": {
    "endpoint": "https://openrouter.ai/api/v1/chat/completions",
    "model": "qwen/qwen3-32b:free",
    "apiKey": "your_api_key_here"
  },
  "mcpServers": [
    "http://localhost:8080"
  ]
}`;

        window.onload = function () {
            const savedConfig = getConfig();
            document.getElementById('config').value = savedConfig || defaultConfig;
        };

        function toggleConfig() {
            const panel = document.getElementById('configPanel');
            const button = document.querySelector('.toggle-button');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                button.textContent = 'Hide Configuration';
            } else {
                panel.style.display = 'none';
                button.textContent = 'Show Configuration';
            }
        }

        async function run() {
            const configText = document.getElementById('config').value;
            setConfig(configText);
            const config = JSON.parse(configText);
            const userInput = document.getElementById('userInput').value;
            const output = document.getElementById('output');
            output.textContent = "Fetching tool descriptions...\n";

            // Découverte des outils via la lib MCP officielle
            let tools = [];
            for (const server of config.mcpServers) {
                try {
                    // Utilisation de la lib MCP officielle
                    // Si UMD : window.mcpTools.discoverTools
                    const discovered = await window.mcpTools.discoverTools(server);
                    tools = tools.concat(discovered.tools || []);
                    output.textContent += `Loaded tools from ${server}.\n`;
                } catch (err) {
                    output.textContent += `Error fetching tools from ${server}: ${err}\n`;
                }
            }

            // Build tool descriptions to inject into prompt
            const toolDescriptions = tools.map(tool => {
                return `Function name: ${tool.function.name}
Description: ${tool.function.description || 'No description'}
Parameters: ${JSON.stringify(tool.function.parameters, null, 2)}\n`;
            }).join('\n');

            let history = [
                {
                    role: "system",
                    content: `You can use the following tools by calling a function.\n${toolDescriptions}`
                },
                {
                    role: "user",
                    content: userInput
                }
            ];

            let finalResponse = "";
            let functionCall = null;

            const res = await fetch(config.llm.endpoint, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${config.llm.apiKey}`
                },
                body: JSON.stringify({
                    model: config.llm.model,
                    messages: history,
                    stream: true
                })
            });

            const reader = res.body.getReader();
            const decoder = new TextDecoder("utf-8");

            while (true) {
                const { value, done } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                for (const line of chunk.split("\n")) {
                    if (line.startsWith("data:")) {
                        const json = line.replace(/^data:\s*/, "");
                        if (json === "[DONE]") break;
                        try {
                            const parsed = JSON.parse(json);
                            const choice = parsed.choices?.[0];
                            const delta = choice.delta;

                            if (delta.content) {
                                finalResponse += delta.content;
                                output.textContent = finalResponse;
                            }

                            if (delta.function_call) {
                                if (!functionCall) functionCall = { name: "", arguments: "" };
                                if (delta.function_call.name) functionCall.name += delta.function_call.name;
                                if (delta.function_call.arguments) functionCall.arguments += delta.function_call.arguments;
                            }
                        } catch (e) {
                            console.warn("Stream parse error:", e);
                        }
                    }
                }
            }

            if (functionCall) {
                output.textContent += `\n\nFunction call: ${functionCall.name}(${functionCall.arguments})\n`;
                const args = JSON.parse(functionCall.arguments);
                const tool = tools.find(t => t.function.name === functionCall.name);
                if (!tool) {
                    output.textContent += `Tool ${functionCall.name} not found\n`;
                    return;
                }
                // Appel standard MCP avec la lib
                const mcpResult = await window.mcpTools.callTool(tool, args);
                output.textContent += `\nTool response (${functionCall.name}): ${JSON.stringify(mcpResult, null, 2)}\n`;

                // Send tool result back to LLM
                history.push({
                    role: "assistant",
                    content: null,
                    function_call: {
                        name: functionCall.name,
                        arguments: functionCall.arguments
                    }
                });

                history.push({
                    role: "tool",
                    content: JSON.stringify(mcpResult)
                });

                const finalRes = await fetch(config.llm.endpoint, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": `Bearer ${config.llm.apiKey}`
                    },
                    body: JSON.stringify({
                        model: config.llm.model,
                        messages: history
                    })
                });

                const finalJson = await finalRes.json();
                const finalMessage = finalJson.choices?.[0]?.message;
                output.textContent += `\n\nFinal LLM Response:\n${finalMessage.content}`;
            }
        }
    </script>
</body>

</html>
